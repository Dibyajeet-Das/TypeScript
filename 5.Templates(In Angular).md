Think of it like this:

**Normal HTML** = shows static content  
**Angular template** = shows dynamic content and controls what the app does

An Angular template is an HTML file that tells Angular what to show on the screen and how the user moves or interacts with the app.

### Example

#### Component file (`app.component.ts`)

`@Component({   selector: 'app-root',   templateUrl: './app.component.html' }) export class AppComponent {   name = 'John'; }`

### Template file (`app.component.html`)

`<h1>Hello {{ name }}</h1>`

Angular replaces `{{ name }}` with **John**  
The screen shows: **Hello John**


# Data Binding

In an Angular template, a binding creates a live connection between a part of the UI created from a template (a DOM element, directive, or component) and the model (the component instance to which the template belongs). This connection can be used to synchronize the view with the model, to notify the model when an event or user action takes place in the view, or both. Angular's Change Detection algorithm is responsible for keeping the view and the model in sync. Bindings always have two parts: a target which will receive the bound value, and a template expression which produces a value from the model.


![[Pasted image 20251224210640.png]]


![[Pasted image 20251224210719.png]]

generally an event occurs in the template section when we performs action in it as response some
logic use to be performed in the component section.

we also get the information as well using the event as well 

## Basic Syntax

Use `(eventName)="method($event)"` in templates to bind events. Common events include `click`, `input`, `keyup`, and `submit`.[](https://www.geeksforgeeks.org/angular-js/event-binding-in-angular-8/)​

## Code Example

**Template (app.component.html):**

xml

`<button (click)="handleClick($event)">Click Me</button> <input type="text" (input)="handleInput($event)" placeholder="Type here">`

**Component (app.component.ts):**

typescript

``import { Component } from '@angular/core'; @Component({   selector: 'app-root',  templateUrl: './app.component.html' }) export class AppComponent {   message = '';   handleClick(event: MouseEvent) {    // Access event meta: coordinates, target, timestamp    console.log('Clicked at:', event.clientX, event.clientY);    console.log('Target:', event.target);    console.log('Timestamp:', event.timeStamp);    event.preventDefault(); // Stops default behavior    this.message = `Clicked at (${event.clientX}, ${event.clientY})`;  }   handleInput(event: InputEvent) {    // Access input meta: value, target element    const target = event.target as HTMLInputElement;    console.log('Input value:', target.value);    console.log('Selection start:', target.selectionStart);    this.message = `You typed: ${target.value}`;  } }``

This captures event metadata like coordinates, timestamps, and input values for processing.


# Attribute Binding
## Basic Syntax

Apply `[attr.attributeName]="expression"` in templates for dynamic attribute values from component properties or methods. Use it for attributes without DOM equivalents.

## Code Example

**Template (app.component.html):**

xml

`<button [attr.aria-label]="isActive ? 'Close button' : 'Open button'"          [attr.role]="buttonRole" (click)="toggleActive()">  {{ isActive ? 'Close' : 'Open' }} </button> <table>   <tr [attr.colspan]="isWide ? 2 : 1">    <td>Dynamic content</td>  </tr> </table>`

**Component (app.component.ts):**

typescript

```
`import { Component } from '@angular/core'; 
@Component({   
	selector: 'app-root',  
	templateUrl: './app.component.html' 
}) 
export class AppComponent {   
	isActive = false;  
	buttonRole = 'button';  
	isWide = true;   
	toggleActive() {    
	this.isActive = !this.isActive;    
	console.log('ARIA label updated:', this.isActive ? 'Close button' : 'Open button');  
} }`
```

This example shows meta information like dynamic ARIA labels for screen readers and conditional `colspan` for table structure.​


# Two Way Data Binding 

# Two-way Binding

Two-way binding gives components in your application a way to share data. Use two-way binding to listen for events and update values simultaneously between parent and child components. Angular's two-way binding syntax is a combination of square brackets and parentheses, `[()]`, commonly known as `banana in a box`.



# control flow
Angular’s new template control flow lets you use `@if`, `@for`, and `@switch` directly in templates to show/hide or repeat elements in a clean, JS-like way.[](https://angular.dev/guide/templates/control-flow)​

### Basic idea

- `@if / @else if / @else`: Conditionally render parts of the template (similar to `if/else` in JavaScript).[](https://ultimatecourses.com/blog/angular-if-else-control-flow-blocks-explained)​
    
- `@for`: Loop over a list and render a block for each item (replacement for `*ngFor`).[](https://www.telerik.com/blogs/angular-basics-controlling-flow-angular-templates-if-for-switch)​
    
- `@switch / @case / @default`: Choose one block to render based on a value (like `switch` in JavaScript).​
    

### Small example component

Imagine a simple `user-list` component that:

- Shows a message when the user is **logged in** or **logged out**.
    
- Loops through a list of users.
    
- Shows different text based on the user **role**.
    

## TypeScript

ts

`import { Component, signal } from '@angular/core'; @Component({   selector: 'app-user-list',  standalone: true,  templateUrl: './user-list.component.html', }) export class UserListComponent {   isLoggedIn = signal(true);   users = signal([    { id: 1, name: 'Alice', role: 'admin' },    { id: 2, name: 'Bob', role: 'editor' },    { id: 3, name: 'Charlie', role: 'viewer' },  ]); }`

## Template (Angular 17+ control flow)

xml

`<!-- 1. Conditional: @if / @else --> @if (isLoggedIn()) {   <p>Welcome back!</p> } @else {   <p>Please log in to continue.</p> } <hr /> <!-- 2. Looping: @for with @empty --> <ul>   @for (user of users(); track user.id) {    <li>      {{ user.name }}      <!-- 3. Switch on role -->      @switch (user.role) {        @case ('admin')  { - has full access }        @case ('editor') { - can edit content }        @default         { - read-only user }      }    </li>  } @empty {    <li>No users found.</li>  } </ul>`

## What’s happening here

- The first block uses `@if` to show either the logged-in or logged-out message based on `isLoggedIn()`.​
    
- The `@for` block loops over `users()` and renders one `<li>` per user, using `track user.id` for efficient DOM updates.​
    
- Inside each `<li>`, `@switch` decides which message to show for that user based on `user.role` (`admin`, `editor`, or default).​





# Reference vars

Template reference variables help you use data from one part of a template in another part of the template. A template variable can refer to a DOM element within a template, component or directive. In the template, use the hash symbol, `#`, to declare a template reference variable.


